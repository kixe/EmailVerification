<?php

/**
 * ProcessWire Module Email Verification
 *
 * E-Mail Verification and Domain Validation via API.
 * checks an email addresses against blacklist and availability of mailhost.
 * Blacklisted domains are simply stored in a text file. Easy to edit.
 * 
 * made by kixe (Christoph Thelen) 05.10.14
 * Licensed under GNU/GPL v3
 * 
 * 
 * ProcessWire 2.x 
 * Copyright (C) 2013 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 */

class EmailVerification extends WireData implements Module {

	public static function getModuleInfo() {

		return array(

			'title' => 'Email Verification', 
			'version' => 113, 
			'summary' => __('E-Mail Verification and Domain Validation via API. Checks an email address against blacklist and availability of mailhost. Blacklisted domains and email addresses are simply stored in a text file. Easy to edit.'),
			'href' => 'https://processwire.com/talk/topic/7826-module-email-verification/',
			'author' => 'kixe',
			'icon' => 'envelope-o',
			'license' => 'GNU-GPLv3',
			'hreflicense' => 'http://www.gnu.org/licenses/gpl-3.0.html'
			);
	}

	public function __construct() {
	    // intentionally empty
	}

	/*
	public static function allowedExtraChars() {
		return array(
			'de' => 'àáâãäåāăąæçćĉċčďđèéêëēĕėęěŋðĝğġģĥħìíîïĩīĭįıĵķĸĺļľłñńņňòóôõöøōŏőœŕŗřśŝşšţťŧþùúûüũūŭůűųŵýÿŷźżž',
			'no' => 'áàäčçđéèêŋńñóòôöšŧüžæøå',
			'se' => 'àáäåæçèéêëìíîïðñòóôöøùúüýþćčđěłńŋřśšţŧźžǎǐǒǔǥǧǩǯəʒ', // plus Hebrew
			'dk' => 'äåæéöøü',
			'is' => 'áéýúíóþæöð',
			'it' => 'àâäèéêëìîïòôöùûüæœçÿ',
			'fr' => 'àáâãäåæçèéêëìíîïñòóôõöùúûüýÿœ',
			'nu' => 'àáâäåāæçèéêëēìíîïīðñŋòóôõöøōùúûüūýþÿ',
			'be' => 'àáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿœ',
			'de' => 'àáâãäåāăąæçćĉċčďđèéêëēĕėęěŋðĝğġģĥħìíîïĩīĭįıĵķĸĺļľłñńņňòóôõöøōŏőœŕŗřśŝşšţťŧþùúûüũūŭůűųŵýÿŷźżž',
			'biz' => 'àáäåæéêíðñòóôöøúüýþ'
		);
	}
	*/

	public function init() {
		$this->updateMogelmail();
	}

	/**
	 *
	 * @return array of all TLDs by IANA punycoded, uppercase, local text file updated monthly (30 days)
	 */
	public function getTLDs($cycle=2592000) {
		$source = "https://data.iana.org/TLD/tlds-alpha-by-domain.txt";
		$file = __DIR__.'/tlds-alpha-by-domain.txt';
		if (!file_exists($file) || time() - filemtime($file) > $cycle) {
			$update = file_get_contents($source);
			if (file_put_contents($file,$update, LOCK_EX) === false) {
				$this->error("Update of tlds-alpha-by-domain.txt failed");
				return false;
			}
		}
		$tld = array_filter(file($file,FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES), function($e) { return (substr($e,0,1) == '#')?false:true; });
		return $tld;
	}

	/**
	 *
	 * @return bool valid TLD
	 */
	public function validTLD($tld) {
		return in_array(strtoupper(idn_to_ascii($tld)), $this->getTLDs())?true:false;
	}

	/**
	 * extract the part of a string after the last @ if exists
	 * @param string (email)
	 * @return null/ string (domain)
	 */
	public function getDomain($str = null) {
		return strpos($str,'@')?substr(strrchr($str,'@'),1):$str;		
	}

	/**
	 *
	 * @param string (domainname)
	 * @return boolean
	 *
	 */
	public function validDomainName($domainname = '') {		
		if (strlen($domainname) > 255 || strlen($domainname) < 2) return false;
		return ($this->validHostName(idn_to_ascii($domainname)))?true:false;
	}

	/**
	 * to verify a domain name you have to convert to punycode before
	 * @param string (hostname) allowed characters A-Z, a-z, 0-9 and hyphen
	 * @return boolean/ string
	 */
	public function validHostName($hostname = '') {
		if (strlen($hostname) > 255 || strlen($hostname) < 2) return false;
		$matches = array();
		$pattern = '/^((?!-)[a-z0-9-]{1,63}(?<!-)\.)+([a-z]{2,63}|xn--[a-z0-9]{2,63}){1}$/i';
		if (!preg_match($pattern,$hostname,$matches)) return false;
		if (!$this->validTLD($matches[count($matches)-1])) return false;
		return $hostname;
	}

	/**
	 *
	 * @param string (domain/ email address)
	 * @return null/ boolean
	 */
	public function blacklisted($input = null) {
		if (!$input) return null;
		$domain = $this->getDomain($input);
		if (!file_exists(__DIR__.'/mogelmails.txt')) return false;
		$file = file(__DIR__.'/mogelmails.txt', FILE_IGNORE_NEW_LINES);
		if(in_array(idn_to_ascii($domain),$file)) return $domain;
		return false;
	}

	/**
	 *
	 * @param string (domain/ email address)
	 * @return null/ boolean/ string
	 */
	public function hostavailable($input = null) {
		if (!$input) return null;
		$domain = $this->getDomain($input);
		if(checkdnsrr($domain, "MX") || checkdnsrr($domain, "A")) return true;
		return false;
	}
	
	/**
	 *
	 * if this service is used you have to respect terms of use
	 * http://www.mogelmail.de/api
	 *
	 * @param string (domain/ email address)
	 * @return boolean (0,1)
	 * @return null if no argument
	 * 
	 */
	public function mogelmail($input = null) {
		if (!$input) return null;
		$domain = $this->getDomain($input);
		$source = "http://www.mogelmail.de/q/$domain";
		return file_get_contents($source);
	}
	
	/**
	 *
	 * if this service is used you have to respect terms of use
	 * http://www.mogelmail.de
	 *
	 * @return array of mogelmail objects
	 * 
	 */
	protected function getMogelmailArray() {
		$source = "http://www.mogelmail.de/mogelmails.xml";
		$xml = simplexml_load_file($source);
		return $xml;
	}

	/**
	 *
	 * @param int (seconds update cycle) default weekly
	 * @return int number of updated mogeldomains
	 * 
	 */
	public function updateMogelmail($cycle=604800) {
		$file = __DIR__.'/mogelmails.txt';
		if (!file_exists($file) || time() - filemtime($file) > $cycle) {
			if(!$mogelmails = $this->getMogelmailArray()) return false;
			$update = 0;
			$new='';
			foreach ($mogelmails as $mogelmail) {
				$domain = (string)$mogelmail->domain;
				if ($this->blacklisted($domain)) continue; // found in list
				$new .= "$domain\n";
				$update++;
			}
			if (strlen($new) && $this->add(trim($new),false)) return $update;
		}
		return null;
	}

	/**
	 *
	 * max 50 entries to check availability because takes long time to check !!
	 *
	 * @param int (array keys from - to)
	 * @return array/ boolean
	 *
	 */
	public function checkBlacklist($from = 0, $to = 10) {
		if (!file_exists(__DIR__.'/mogelmails.txt')) return false;
		$file = file(__DIR__.'/mogelmails.txt');
		$file = array_map('trim',array_slice($file, $from, $to));
		$num = count($file);
		foreach ($file as $nastymail) {
			if(checkdnsrr($nastymail, "MX")) $list[$nastymail] = 'MX';
			elseif (checkdnsrr($nastymail, "A")) $list[$nastymail] = 'A';
			else $list[$nastymail] = false;
		}		
		return $list;
	}

	/**
	 *
	 * update blacklist with single email address or maildomain
	 * 
	 * @param string (domain/ email address)
	 * @return boolean
	 */
	public function addToBlacklist($input) {
		if ($this->blacklisted($input)) return false;
		if (!$this->hostavailable($input)) return false;
		if ($this->add($this->getDomain($input),false)) return true;		
		return false;
	}

	/**
	 *
	 * update or overwrite blacklist
	 * 
	 * @param string
	 * @return boolean
	 */
	protected function add($string,$replace=false) {
		if (!file_exists(__DIR__.'/mogelmails.txt')) $replace = true;
		$replace = $replace?'w':'a';
		if ($file = fopen(__DIR__.'/mogelmails.txt', $replace)) {
			flock($file, LOCK_EX);
			$nl = $replace?"\n":'';
			fwrite($file, $nl.$string);
			flock($file, LOCK_UN);
			fclose($file);
			chmod(__DIR__.'/mogelmails.txt', 0777);
			return true;
		} else {
			return false;
		}		
	}

	/**
	 * 
	 * delete surrounding spaces and tabs
	 * remove empty lines
	 * delete duplicates
	 * sort alphabetic
	 *
	 * @return multiple array of total number of entries, deleted emptylines and deleted duplicates (value => number)
	 */
	public function clean() {
		if(!is_writable(__DIR__.'/mogelmails.txt')) return $this->error('File or permission missing [mogelmails.txt]');
		$return = array();

		$file = file(__DIR__.'/mogelmails.txt');
		$file = array_map('trim',$file); //delete surrounding spaces and remove linebreaks
		$uniques = array_unique($file); //delete duplicates
		$dupes = array_diff_key( $file, $uniques); // array of duplicates

		sort($uniques); // sort alphabetic
		if($uniques[0] == "") {
			array_shift($uniques); // delete empty string
			$return['deleted_emptystrings'] = 1;
		} else {
			$return['deleted_emptystrings'] = 0;		
		}
		$return['totalnum'] = count($uniques);
		$uniques = implode("\n",$uniques); //add linebreaks
		$this->add(trim($uniques),true); //overwrite

		$return['deleted_duplicates'] = array_count_values($dupes);
		if (array_key_exists('', $return['deleted_duplicates'])) $return['deleted_emptystrings'] += $return['deleted_duplicates'][''];
		unset($return['deleted_duplicates']['']);

		return $return;		
	}
}
