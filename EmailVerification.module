<?php

/**
 * ProcessWire Module Email Verification
 *
 * E-Mail Verification and Domain Validation via API.
 * checks an email addresses against blacklist and availability of mailhost.
 * Blacklisted domains are simply stored in a text file. Easy to edit.
 *
 * @author Christoph Thelen aka @kixe 2014/10/05
 * @copyright © 2014 Christoph Thelen
 * @license Licensed under GNU/GPL v3
 * @link https://processwire.com/talk/topic/...
 * @version 1.2.3
 * @since 1.2.0 2018/02/18 - update email check via fiddlemail.com/ mogelmail.de
 * @since 1.2.1 2018/02/18 - update return value add() and addToBlacklist()
 * @since 1.2.2 2018/02/18 - fixed minor bugs
 * @since 1.2.3 2018/03/28 - fixed bug array to string conversion update() added json_encode()
 * 
 * 
 * ProcessWire 2.x/ 3.x 
 * Copyright (C) 2013 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 */

class EmailVerification extends WireData implements Module {

	public static function getModuleInfo() {

		return array(

			'title' => 'Email Verification', 
			'version' => 123, 
			'summary' => __('E-Mail Verification and Domain Validation via API. Checks an email address against blacklist and availability of mailhost. Blacklisted domains and email addresses are simply stored in a text file. Easy to edit.'),
			'href' => 'https://processwire.com/talk/topic/7826-module-email-verification/',
			'author' => 'kixe',
			'icon' => 'envelope-o',
			'license' => 'GNU-GPLv3',
			'hreflicense' => 'http://www.gnu.org/licenses/gpl-3.0.html'
			);
	}

	protected $filepath;

	public function __construct() {
	    // intentionally empty
	}

	/*
	public static function allowedExtraChars() {
		return array(
			'de' => 'àáâãäåāăąæçćĉċčďđèéêëēĕėęěŋðĝğġģĥħìíîïĩīĭįıĵķĸĺļľłñńņňòóôõöøōŏőœŕŗřśŝşšţťŧþùúûüũūŭůűųŵýÿŷźżž',
			'no' => 'áàäčçđéèêŋńñóòôöšŧüžæøå',
			'se' => 'àáäåæçèéêëìíîïðñòóôöøùúüýþćčđěłńŋřśšţŧźžǎǐǒǔǥǧǩǯəʒ', // plus Hebrew
			'dk' => 'äåæéöøü',
			'is' => 'áéýúíóþæöð',
			'it' => 'àâäèéêëìîïòôöùûüæœçÿ',
			'fr' => 'àáâãäåæçèéêëìíîïñòóôõöùúûüýÿœ',
			'nu' => 'àáâäåāæçèéêëēìíîïīðñŋòóôõöøōùúûüūýþÿ',
			'be' => 'àáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿœ',
			'de' => 'àáâãäåāăąæçćĉċčďđèéêëēĕėęěŋðĝğġģĥħìíîïĩīĭįıĵķĸĺļľłñńņňòóôõöøōŏőœŕŗřśŝşšţťŧþùúûüũūŭůűųŵýÿŷźżž',
			'biz' => 'àáäåæéêíðñòóôöøúüýþ'
		);
	}
	*/

	public function init() {
		$this->filepath = __DIR__ .'/blacklist.txt';
		$this->update();
	}

	/**
	 * get array of all TLDs by IANA punycoded, uppercase, local text file updated monthly (30 days)
	 *
	 * @param $cycle int cycle time to update the tld file
	 * @return array
	 *
	 */
	public function getTLDs($cycle=2592000) {
		$source = "https://data.iana.org/TLD/tlds-alpha-by-domain.txt";
		$file = __DIR__.'/tlds-alpha-by-domain.txt';
		if (!file_exists($file) || time() - filemtime($file) > $cycle) {
			$update = file_get_contents($source);
			if (file_put_contents($file,$update, LOCK_EX) === false) {
				$this->error("Update of tlds-alpha-by-domain.txt failed");
				return false;
			}
		}
		$tld = array_filter(file($file,FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES), function($e) { return (substr($e,0,1) == '#')?false:true; });
		return $tld;
	}

	/**
	 * check if this is a valid top level domain
	 *
	 * @param $tld string top level domain
	 * @return bool valid TLD
	 *
	 */
	public function validTLD($tld) {
		return in_array(strtoupper($this->idn_to_ascii($tld)), $this->getTLDs())? true : false;
	}

	/**
	 * convert domain name to IDNA ASCII form
	 * PHP::idn_to_ascii() needs intl extension installed
	 *
	 * @param $value string top level domain
	 * @return string IDNA ASCII form
	 *
	 */
	protected function idn_to_ascii($value) {
		if(function_exists("idn_to_ascii")) {
			// use native php function if available
			return \idn_to_ascii($value, IDNA_NONTRANSITIONAL_TO_ASCII, INTL_IDNA_VARIANT_UTS46);
		} else {
			// otherwise use PW Punycode class
			$pc = new Punycode();
			return $pc->encode($value);
		}
	}

	/**
	 * extract the part of a string after the last @ if exists
	 *
	 * @param $str string (email)
	 * @return null/ string (domain)
	 */
	public function getDomain($str = null) {
		return strpos($str,'@')?substr(strrchr($str,'@'),1) : $str;		
	}

	/**
	 * validate a domain name
	 *
	 * @param string (domainname)
	 * @return boolean
	 *
	 */
	public function validDomainName($domainname = '') {		
		if (strlen($domainname) > 255 || strlen($domainname) < 2) return false;
		return ($this->validHostName($this->idn_to_ascii($domainname)))?true : false;
	}

	/**
	 * to verify a domain name you have to convert to punycode before
	 * @param string (hostname) allowed characters A-Z, a-z, 0-9 and hyphen
	 * @return boolean/ string
	 */
	public function validHostName($hostname = '') {
		if (strlen($hostname) > 255 || strlen($hostname) < 2) return false;
		$matches = array();
		$pattern = '/^((?!-)[a-z0-9-]{1,63}(?<!-)\.)+([a-z]{2,63}|xn--[a-z0-9]{2,63}){1}$/i';
		if (!preg_match($pattern,$hostname,$matches)) return false;
		if (!$this->validTLD($matches[count($matches)-1])) return false;
		return $hostname;
	}

	/**
	 * Determine if given domain or Email is blacklisted, update blacklist file (max. once per week)
	 *
	 * @param $input string (domain/ email address)
	 * @param $cycle int
	 * @return null/ boolean/ string
	 */
	public function blacklisted($input = null) {
		if (!$input) return null;
		$domain = $this->getDomain($input);
		if (file_exists($this->filepath)) {
			$file = file($this->filepath, FILE_IGNORE_NEW_LINES);
			if(in_array($this->idn_to_ascii($domain),$file)) return $domain;
		}
		if (!$this->validHost($domain)) return false;
		else if (!file_exists($this->filepath) || time() - filemtime($this->filepath) > 604800) {
			$check = $this->mogelmail($domain);
			if ($check) return $this->add($domain);
		}
		return false;
	}

	/**
	 * Check DNS records corresponding to a given Internet host name or IP address
	 *
	 * @param $input string (domain/ email address)
	 * @return null/ boolean/ string
	 */
	public function validHost($input = null) {
		if (!$input) return null;
		$domain = $this->getDomain($input);
		if (!$this->validDomainName($domain)) return false;
		if (checkdnsrr($domain, "MX")) return "MX";
		if (checkdnsrr($domain, "A")) return "A";
		return false;
	}
	
	/**
	 *
	 * if this service is used you have to respect terms of use
	 * https://fiddlemail.com/info/terms.html
	 * this function runs maximum once per week
	 *
	 * @param $input string (domain/ email address)
	 * @return null/ boolean
	 * @return null if no argument
	 * @deprecated (maybe?) use api key in future
	 * 
	 */
	protected function mogelmail($input = null) {
		if (!$input) return null;
		$domain = $this->getDomain($input);
		$source = "https://fiddlemail.com/q/$domain"; // return string (0 or 1)
		if (!$this->checkRemoteFileAccess($source)) return null;
		$return = file_get_contents($source);
		if (!is_numeric($return)) $this->error("Unexpected return value ($source)", Notice::logOnly);
		else return (bool) $return;
	}

	/**
	 *
	 * manually update blacklist with single email address or maildomain
	 * 
	 * @param $input string (domain/ email address)
	 * @return boolean/ string
	 */
	public function addToBlacklist($input) {
		$domain = $this->getDomain($input);
		if (!$this->validHost($domain)) return false;
		return $this->add($domain, false);
	}

	/**
	 * add suspected domain to blacklist file
	 * update or create new blacklist with a single entry
	 * 
	 * @param $domain string
	 * @return boolean
	 */
	protected function add($domain, $create = false) {
		if (!file_exists($this->filepath)) $create = true;
		$nl = $create? '' : "\n";
		$create = $create ? 'w' : 'a';
		if ($file = fopen($this->filepath, $create)) {
			flock($file, LOCK_EX);
			fwrite($file, $nl.$domain);
			flock($file, LOCK_UN);
			fclose($file);
			// chmod($this->filepath, 0777); // warning: operation not permitted
			return $domain;
		} else {
			return false;
		}		
	}

	/**
	 * checks accessibility of remote file, expects http status codes: 200 or 302 only
	 * logs error if not accessible
	 *
	 * @param $httpUrl
	 * @return bool
	 *
	 */
	protected function checkRemoteFileAccess($httpUrl) {
		$file_headers = @get_headers($httpUrl);
		if (preg_match('/200|302/',$file_headers[0])) return true;
		$error = "Connection to external datasource failed: '$httpUrl'";
		if ($file_headers) $error .= " ($file_headers[0])";
		$this->error($error, Notice::logOnly);
		return false;
	}

	/**
	 * Check DNS records corresponding to domain name in blacklist file
	 * max 50 entries allowed
	 *
	 * @param $from int array key from where to check
	 * @param $to int array key until where to check (max diff to $from = 50)
	 * @return array/ boolean
	 * @see function validHost()
	 *
	 */
	public function checkBlacklistHosts($from = 0, $to = 10) {
		if ($to - $from >= 50) throw new WireException('Maximum number of tests exceeded');
		if (!file_exists($this->filepath)) return false;
		$lines = file($this->filepath);
		$lines = array_map('trim',array_slice($lines, $from, $to));
		$num = count($lines);
		if ($num) {
			$list = array();
			foreach ($lines as $nastymail) {
				$list[$nastymail] = $this->validHost($nastymail);
			}		
			return $list;
		}
		return false;
	}

	/**
	 * clean up blacklist file
	 *
	 * delete surrounding spaces and tabs
	 * remove empty lines
	 * delete duplicates
	 * sort alphabetic
	 *
	 * @return multiple array of total number of entries, deleted emptylines and deleted duplicates (value => number)
	 */
	public function clean() {
		if(!is_writable($this->filepath)) return $this->error("File or permission missing " . $this->filepath);
		$return = array();

		$file = file($this->filepath);
		$file = array_map('trim',$file); //delete surrounding spaces and remove linebreaks
		$uniques = array_unique($file); //delete duplicates
		$dupes = array_diff_key( $file, $uniques); // array of duplicates

		sort($uniques); // sort alphabetic
		if($uniques[0] == "") {
			array_shift($uniques); // delete empty string
			$return['deleted_emptystrings'] = 1;
		} else {
			$return['deleted_emptystrings'] = 0;		
		}
		$return['totalnum'] = count($uniques);
		$uniques = implode("\n",$uniques); //add linebreaks
		$this->add(trim($uniques),true); //overwrite

		$return['deleted_duplicates'] = array_count_values($dupes);
		if (array_key_exists('', $return['deleted_duplicates'])) $return['deleted_emptystrings'] += $return['deleted_duplicates'][''];
		unset($return['deleted_duplicates']['']);

		return $return;		
	}

	/**
	 * cyclical cleaning up of the blacklist file triggered by init
	 *
	 * @return bool
	 * @see init(), clean()
	 * @todo implement checkBlacklistHosts() check only 10 records per check remind $from from last check
	 *
	 */
	protected function update() {
		if (file_exists($this->filepath) && time() - filemtime($this->filepath) > 604800) {
			if ($message = $this->clean()) {
				$message = 'Updated file ' . $this->filepath . json_encode($message);
				$this->message($message, Notice::logOnly);
				return true;
			}
		}
		return false;
	}
}
